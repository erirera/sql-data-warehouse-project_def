Change Over Time Analysis
===============================================================================
Purpose:
    - To track trends, growth, and changes in key metrics over time.
    - For time-series analysis and identifying seasonality.
    - To measure growth or decline over specific periods.

SQL Functions Used:
    - Date Functions: EXTRACT (YEAR FROM...), (EXTRACT MONTH FROM ....), DATE_TRUNC(), TO_CHAR()
    - Aggregate Functions: SUM(), COUNT(), AVG()
===============================================================================
*/

-- Analyse sales performance over time
-- Quick Date Functions in Postgres
SELECT
  EXTRACT(YEAR FROM order_date)::int AS order_year,
  EXTRACT(MONTH FROM order_date)::int AS order_month,
  SUM(sales) AS total_sales,
  COUNT(DISTINCT customer_key) AS total_customers,
  SUM(quantity) AS total_quantity
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY EXTRACT(YEAR FROM order_date)::int, EXTRACT(MONTH FROM order_date)::int
ORDER BY EXTRACT(YEAR FROM order_date)::int, EXTRACT(MONTH FROM order_date)::int;

-- DATETRUNC() in Postgres
SELECT
  date_trunc('month', order_date) AS order_month,
  SUM(sales) AS total_sales,
  COUNT(DISTINCT customer_key) AS total_customers,
  SUM(quantity) AS total_quantity
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY date_trunc('month', order_date)
ORDER BY date_trunc('month', order_date);

-- TO_CHAR()
SELECT
  to_char(date_trunc('month', order_date), 'YYYY-MON') AS order_date,
  SUM(sales) AS total_sales,
  COUNT(DISTINCT customer_key) AS total_customers,
  SUM(quantity) AS total_quantity
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY date_trunc('month', order_date)
ORDER BY date_trunc('month', order_date);

/*
===============================================================================
Cumulative Analysis
===============================================================================
Purpose:
    - To calculate running totals or moving averages for key metrics.
    - To track performance over time cumulatively.
    - Useful for growth analysis or identifying long-term trends.

SQL Functions Used:
    - Window Functions: SUM() OVER(), AVG() OVER()
===============================================================================
*/

-- Calculate the total sales per month 
-- and the running total of sales over time 
-- calendar year (start timestamp), formatted totals and average
SELECT
	year_start,
	total_sales,
	SUM(total_sales) OVER (ORDER BY year_start) AS running_total_sales,
	AVG(avg_price) OVER (ORDER BY year_start) AS moving_average_price
FROM
(
    SELECT
  date_trunc('year', order_date)      AS year_start,
  SUM(sales)::numeric(18,2)           AS total_sales,
  ROUND(AVG(price)::numeric, 2)       AS avg_price
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY 1
ORDER BY 1
) t

-- calendar month (start timestamp), formatted totals and average
SELECT
	month_start,
	total_sales,
	SUM(total_sales) OVER (ORDER BY month_start) AS running_total_sales,
	AVG(avg_price) OVER (ORDER BY month_start) AS moving_average_price
FROM
(
    SELECT
  date_trunc('month', order_date)      AS month_start,
  SUM(sales)::numeric(18,2)           AS total_sales,
  ROUND(AVG(price)::numeric, 2)       AS avg_price
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY 1
ORDER BY 1
) t
-- Alternative year as integer (easier for joins/labels)
SELECT
	year,
	total_sales,
	SUM(total_sales) OVER (ORDER BY year) AS running_total_sales,
	AVG(avg_price) OVER (ORDER BY year) AS moving_average_price
FROM
(
    SELECT
  EXTRACT(YEAR FROM order_date)::int AS year,
  SUM(sales)::numeric(18,2)           AS total_sales,
  ROUND(AVG(price)::numeric, 3)       AS avg_price
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY 1
ORDER BY 1
) t

-- Alternative month as integer (easier for joins/labels)
SELECT
	month,
	total_sales,
	SUM(total_sales) OVER (ORDER BY month) AS running_total_sales,
	AVG(avg_price) OVER (ORDER BY month) AS moving_average_price
FROM
(
    SELECT
  EXTRACT(month FROM order_date)::int AS month,
  SUM(sales)::numeric(18,2)           AS total_sales,
  ROUND(AVG(price)::numeric, 2)       AS avg_price
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY 1
ORDER BY 1
) t

/*
===============================================================================
Performance Analysis (Year-over-Year, Month-over-Month)
===============================================================================
Purpose:
    - To measure the performance of products, customers, or regions over time.
    - For benchmarking and identifying high-performing entities.
    - To track yearly trends and growth.

SQL Functions Used:
    - LAG(): Accesses data from previous rows.
    - AVG() OVER(): Computes average values within partitions.
    - CASE: Defines conditional logic for trend analysis.
	- EXTRACT(YEAR FROM): Extracts year from order_date
===============================================================================
*/

/* Analyze the yearly performance of products by comparing their sales 
to both the average sales performance of the product and the previous year's sales */
WITH yearly_product_sales AS (
    SELECT
        EXTRACT(YEAR FROM f.order_date)::int AS order_year,
        p.product_name,
        SUM(f.sales) AS current_sales
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_products p
        ON f.product_key = p.product_key
    WHERE f.order_date IS NOT NULL
    GROUP BY 
        EXTRACT(YEAR FROM f.order_date),
        p.product_name
),

sales_metrics AS (
    SELECT
        order_year,
        product_name,
        current_sales,
        AVG(current_sales) OVER (PARTITION BY product_name) AS avg_sales,
        LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) AS py_sales
    FROM yearly_product_sales
)

SELECT
    order_year,
    product_name,
    current_sales,
    avg_sales,
    current_sales - avg_sales AS diff_avg,
    -- percent difference vs average; NULL if avg_sales is 0 or NULL
    ROUND(100.0 * (current_sales - avg_sales) / NULLIF(avg_sales, 0), 2) AS pct_change_vs_avg,
    CASE 
        WHEN current_sales > avg_sales THEN 'Above Avg'
        WHEN current_sales < avg_sales THEN 'Below Avg'
        ELSE 'Avg'
    END AS avg_change,
    -- Year-over-Year Analysis
    py_sales,
    current_sales - py_sales AS diff_py,
    -- YoY percent change; NULL if py_sales is 0 or NULL
    ROUND(100.0 * (current_sales - py_sales) / NULLIF(py_sales, 0), 2) AS pct_change_py,
    CASE 
        WHEN py_sales IS NULL THEN 'No Prior Year'
        WHEN current_sales > py_sales THEN 'Increase'
        WHEN current_sales < py_sales THEN 'Decrease'
        ELSE 'No Change'
    END AS py_change
FROM sales_metrics
ORDER BY product_name, order_year;


/*
===============================================================================
Part-to-Whole Analysis
===============================================================================
Purpose:
    - To compare performance or metrics across dimensions or time periods.
    - To evaluate differences between categories.
    - Useful for A/B testing or regional comparisons.

SQL Functions Used:
    - SUM(), AVG(): Aggregates values for comparison.
    - Window Functions: SUM() OVER() for total calculations.
	- NULLIF() and ROUND() functions
===============================================================================
*/
-- Which categories contribute the most to overall sales?
WITH category_sales AS (
    SELECT
        p.category,
        SUM(f.sales) AS total_sales
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_products p
        ON p.product_key = f.product_key
    GROUP BY p.category
)
SELECT
    category,
    total_sales,
    SUM(total_sales) OVER () AS overall_sales,
    ROUND(
        (total_sales::numeric / NULLIF(SUM(total_sales) OVER (), 0)) * 100,
        2
    ) AS percentage_of_total
-- CONCAT(ROUND(
        (total_sales::numeric / NULLIF(SUM(total_sales) OVER (), 0)) * 100,
        2),'%'
FROM category_sales
ORDER BY total_sales DESC;

/*
===============================================================================
Data Segmentation Analysis
===============================================================================
Purpose:
    - To group data into meaningful categories for targeted insights.
    - For customer segmentation, product categorization, or regional analysis.

SQL Functions Used:
    - CASE: Defines custom segmentation logic.
    - GROUP BY: Groups data into segments.
===============================================================================
*/

/*Segment products into cost ranges and 
count how many products fall into each segment*/
WITH product_segments AS (
    SELECT
        product_key,
        product_name,
        cost,
        CASE 
            WHEN cost < 100 THEN 'Below 100'
            WHEN cost >= 100 AND cost < 500 THEN '100-499'
            WHEN cost >= 500 AND cost < 1000 THEN '500-999'
            ELSE '1000+'
        END AS cost_range
    FROM gold.dim_products
    WHERE cost IS NOT NULL
)
SELECT 
    cost_range,
    COUNT(product_key) AS total_products
FROM product_segments
GROUP BY cost_range
ORDER BY total_products DESC;

/*
Rules:
 - VIP:     lifespan >= 12 months AND total_spending > 5000
 - Regular: lifespan >= 12 months AND total_spending <= 5000
 - New:     lifespan <  12 months (including customers with no orders)
Notes:
 - lifespan_months is computed via age(max_order, min_order) and converted to months.
 - total_spending uses COALESCE to treat no-sales as 0.
 - DATE_PART computes each customer's lifespan in whole months (difference between their first and last order) and returns 0 when there are no orders.
 - MIN(f.order_date) and MAX(f.order_date): Find the earliest and latest order dates per customer (or per grouping in the surrounding aggregate).
	age(MAX(...), MIN(...)). 
	- DATE_PART('year', ...) * 12 + DATE_PART('month', ...): Converts years to months and add the remaining months to get total whole months.
	- (...)::int: Cast the result to integer (truncates if it were fractional â€” though DATE_PART here returns numeric integer parts already).
	- COALESCE(..., 0) If any part of the calculation is NULL (for example MIN or MAX are NULL because the customer has no orders), COALESCE returns 0 instead of NULL.
*/
WITH customer_spending AS (
    SELECT
        c.customer_key,
        COALESCE(SUM(f.sales), 0)::numeric AS total_spending,
        MIN(f.order_date)        AS first_order,
        MAX(f.order_date)        AS last_order,
        COALESCE(
            (
                DATE_PART('year', age(MAX(f.order_date), MIN(f.order_date))) * 12
                + DATE_PART('month', age(MAX(f.order_date), MIN(f.order_date)))
            )::int,
            0
        ) AS lifespan_months
    FROM gold.dim_customers c
    LEFT JOIN gold.fact_sales f
        ON f.customer_key = c.customer_key
    GROUP BY c.customer_key
)

SELECT 
    customer_segment,
    COUNT(*) AS total_customers
FROM (
    SELECT 
        customer_key,
        CASE 
            WHEN lifespan_months >= 12 AND total_spending > 5000 THEN 'VIP'
            WHEN lifespan_months >= 12 AND total_spending <= 5000 THEN 'Regular'
            ELSE 'New'
        END AS customer_segment
    FROM customer_spending
) AS segmented_customers
GROUP BY customer_segment
ORDER BY total_customers DESC;
